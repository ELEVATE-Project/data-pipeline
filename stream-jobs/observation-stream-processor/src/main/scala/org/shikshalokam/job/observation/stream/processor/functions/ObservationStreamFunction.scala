package org.shikshalokam.job.observation.stream.processor.functions

import org.apache.flink.api.common.typeinfo.TypeInformation
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.functions.ProcessFunction
import org.shikshalokam.job.observation.stream.processor.domain.Event
import org.shikshalokam.job.observation.stream.processor.task.ObservationStreamConfig
import org.shikshalokam.job.util.{PostgresUtil, ScalaJsonUtil}
import org.shikshalokam.job.{BaseProcessFunction, Metrics}
import org.slf4j.LoggerFactory

import java.util
import java.time.{Instant, ZoneId}
import java.time.format.DateTimeFormatter
import scala.collection.immutable._

class ObservationStreamFunction(config: ObservationStreamConfig)(implicit val mapTypeInfo: TypeInformation[Event], @transient var postgresUtil: PostgresUtil = null)
  extends BaseProcessFunction[Event, Event](config) {

  private[this] val logger = LoggerFactory.getLogger(classOf[ObservationStreamFunction])

  override def metricsList(): List[String] = {
    List(config.observationCleanupHit, config.skipCount, config.successCount, config.totalEventsCount)
  }

  override def open(parameters: Configuration): Unit = {
    super.open(parameters)
    val pgHost: String = config.pgHost
    val pgPort: String = config.pgPort
    val pgUsername: String = config.pgUsername
    val pgPassword: String = config.pgPassword
    val pgDataBase: String = config.pgDataBase
    val connectionUrl: String = s"jdbc:postgresql://$pgHost:$pgPort/$pgDataBase"
    postgresUtil = new PostgresUtil(connectionUrl, pgUsername, pgPassword)
  }

  override def close(): Unit = {
    super.close()
  }

  override def processElement(event: Event, context: ProcessFunction[Event, Event]#Context, metrics: Metrics): Unit = {

    println(s"***************** Start of Processing the Observation Event with Id = ${event._id} *****************")

    println("\n==> domain data ")
    println("solutionId = " + event.solutionId)
    println("submissionId = " + event._id)
    println("userId = " + event.createdBy)
    println("submissionNumber = " + event.submissionNumber)
    println("stateName = " + event.stateName)
    println("districtName = " + event.districtName)
    println("blockName = " + event.blockName)
    println("clusterName = " + event.clusterName)
    println("schoolName = " + event.schoolName)
    println("status = " + event.status)
    println("solutionName = " + event.solutionName)
    val status_of_submission = event.status
    val submission_id = event._id
    val user_id = event.createdBy
    val submission_number = event.submissionNumber
    val state_name = event.stateName
    val state_id = event.stateId
    val district_name = event.districtName
    val district_id = event.districtId
    val block_name = event.blockName
    val block_id = event.blockId
    val cluster_name = event.clusterName
    val cluster_id = event.clusterId
    val school_name = event.schoolName
    val themes = event.themes
    val criteria_event = event.criteria
    val solution_id = event.solutionId
    val solution_name = event.solutionName
    val program_name = event.programName
    val program_id = event.programId
    val observation_name = event.observationName
    val observation_id = event.observationId
    val school_id = event.schoolId
    val org_name = event.orgName
    val org_id = event.orgId
    val completed_date = event.completedDate
    val domainTable = s""""${solution_id}_domain""""
    val questionTable = s""""${solution_id}_questions""""
    val statusTable = s""""${solution_id}_status""""
    val user_roles = event.userRoles
    var roles = ""
    user_roles.foreach { role =>
      roles = user_roles.map(role => role("label").toString).mkString(", ")
    }
    println(s"roles: $roles")


    /**
     * Creating tables if not exists
     */

    def checkAndCreateTable(tableName: String, createTableQuery: String): Unit = {
      val checkTableExistsQuery =
        s"""SELECT EXISTS (
           |  SELECT FROM information_schema.tables
           |  WHERE table_name = '$tableName'
           |);
           |""".stripMargin

      val tableExists = postgresUtil.executeQuery(checkTableExistsQuery) { resultSet =>
        if (resultSet.next()) resultSet.getBoolean(1) else false
      }

      if (!tableExists) {
        postgresUtil.createTable(createTableQuery, tableName)
      }
    }

    if (status_of_submission == "completed") {

      val createDomainsTable =
        s"""CREATE TABLE IF NOT EXISTS $domainTable (
           |    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
           |    user_id TEXT ,
           |    user_roles TEXT,
           |    solution_id TEXT ,
           |    solution_name TEXT,
           |    submission_id TEXT,
           |    submission_number INTEGER,
           |    program_name TEXT,
           |    program_id TEXT,
           |    observation_name TEXT,
           |    observation_id TEXT,
           |    state_name TEXT,
           |    state_id TEXT,
           |    district_name TEXT,
           |    district_id TEXT,
           |    block_name TEXT,
           |    block_id TEXT,
           |    cluster_name TEXT,
           |    cluster_id TEXT,
           |    org_name TEXT,
           |    org_id TEXT,
           |    school_name TEXT,
           |    school_id TEXT,
           |    domain TEXT,
           |    domain_level TEXT,
           |    criteria TEXT,
           |    criteria_level TEXT,
           |    completed_date TEXT
           |);""".stripMargin


      val createQuestionsTable =
        s"""CREATE TABLE IF NOT EXISTS $questionTable (
           |    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
           |    user_id TEXT ,
           |    user_roles TEXT,
           |    solution_id TEXT ,
           |    solution_name TEXT,
           |    submission_id TEXT,
           |    program_name TEXT,
           |    program_id TEXT,
           |    observation_name TEXT,
           |    observation_id TEXT,
           |    state_name TEXT,
           |    district_name TEXT,
           |    block_name TEXT,
           |    cluster_name TEXT,
           |    school_name TEXT,
           |    school_id TEXT,
           |    org_name TEXT,
           |    question_id TEXT,
           |    question_text TEXT,
           |    labels TEXT,
           |    value TEXT,
           |    score INTEGER,
           |    domain_name TEXT,
           |    criteria_name TEXT,
           |    has_parent_question BOOLEAN,
           |    parent_question_text TEXT,
           |    evidence TEXT,
           |    submitted_at TEXT,
           |    remarks TEXT,
           |    question_type TEXT
           |);""".stripMargin

      checkAndCreateTable(domainTable, createDomainsTable)
      checkAndCreateTable(questionTable, createQuestionsTable)

      /**
       * Extracting domain data
       */

      val deleteQuery =
        s"""DELETE FROM $domainTable
           |WHERE user_id = ?
           |  AND state_id = ?
           |  AND district_id = ?
           |  AND block_id = ?
           |  AND cluster_id = ?
           |  AND school_id = ?;
           |""".stripMargin

      val deleteParams = Seq(user_id, state_id, district_id, block_id, cluster_id, school_id)

      postgresUtil.executePreparedUpdate(deleteQuery, deleteParams, domainTable, user_id)

      themes.foreach { domain =>
        val domain_name = domain("name")
        val domain_level = domain.getOrElse("pointsBasedLevel", null)
        val maybeChildren = domain.get("children").map(_.asInstanceOf[List[Map[String, Any]]])
        val maybeCriteria = domain.get("criteria").map(_.asInstanceOf[List[Map[String, Any]]])

        maybeChildren match {
          case Some(subdomains) =>
            subdomains.foreach { subdomain =>
              val maybeSubCriteria = subdomain.get("criteria").map(_.asInstanceOf[List[Map[String, Any]]])
              maybeSubCriteria.foreach { criteriaList =>
                criteriaList.foreach { criteria =>
                  val criteriaId = criteria("criteriaId")

                  criteria_event.find(_("_id") == criteriaId).foreach { crit =>
                  }
                }
              }
            }

          case None =>
            maybeCriteria.foreach { criteriaList =>
              criteriaList.foreach { criteria =>
                val criteriaId = criteria("criteriaId")
                println(s"criteria_id: $criteriaId")

                criteria_event.find(c => c("_id") == criteriaId).foreach { crit =>
                  val criteria_name = crit("name")
                  val criteria_level = crit("score")
                  val insertCriteriaQuery =
                    s"""INSERT INTO $domainTable (
                       |    user_id, user_roles, solution_id, solution_name, submission_id, submission_number, program_name, program_id,
                       |    observation_name, observation_id, state_name, state_id, district_name, district_id, block_name, block_id, cluster_name,
                       |    cluster_id, org_name, org_id, school_name, school_id, domain, domain_level, criteria, criteria_level, completed_date
                       |) VALUES (
                       |        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                       |);
                       |""".stripMargin

                  val criteriaParams = Seq(
                    user_id, roles, solution_id, solution_name, submission_id, submission_number, program_name,
                    program_id, observation_name, observation_id, state_name, state_id, district_name, district_id, block_name, block_id,
                    cluster_name, cluster_id, org_name, org_id, school_name, school_id, domain_name, domain_level, criteria_name, criteria_level, completed_date
                  )

                  postgresUtil.executePreparedUpdate(insertCriteriaQuery, criteriaParams, domainTable, solution_id)
                }
              }
            }
        }
      }

      /**
       * Extracting question data
       */

      val deleteQuestionQuery =
        s"""DELETE FROM $questionTable
           |WHERE user_id = ?
           |  AND state_name = ?
           |  AND district_name = ?
           |  AND block_name = ?
           |  AND cluster_name = ?
           |  AND school_name = ?;
           |""".stripMargin

      val deleteQuestionParams = Seq(user_id, state_name, district_name, block_name, cluster_name, school_name)

      postgresUtil.executePreparedUpdate(deleteQuestionQuery, deleteQuestionParams, questionTable, user_id)

      val questionsFunction = new ObservationQuestionFunction(postgresUtil, config, questionTable)
      val answersKey = event.answers

      def processQuestion(responseType: String, questionsMap: Map[String, Any], payload: Option[Map[String, Any]], question_id: String, domain_name: String,
                          criteria_name: String, has_parent_question: Boolean, parent_question_text: String, evidences: String, remarks: String): Unit = {
        val value: String = questionsMap.get("value") match {
          case Some(v: String) => v
          case Some(v: Int) => v.toString
          case _ => ""
        }
        val score: Integer = questionsMap.get("scoreAchieved") match {
          case Some(v: Integer) => v
          case _ => 0
        }

        responseType match {
          case "text" =>
            questionsFunction.textQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, roles, program_name, program_id,
              observation_name, observation_id, value, state_name, district_name, block_name, cluster_name, school_name, school_id, org_name, domain_name, criteria_name, score,
              has_parent_question, parent_question_text, evidences, remarks, completed_date)
          case "radio" =>
            questionsFunction.radioQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, roles, program_name, program_id,
              observation_name, observation_id, value, state_name, district_name, block_name, cluster_name, school_name, school_id, org_name, domain_name, criteria_name, score,
              has_parent_question, parent_question_text, evidences, remarks, completed_date)
          case "date" =>
            questionsFunction.dateQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, roles, program_name, program_id,
              observation_name, observation_id, value, state_name, district_name, block_name, cluster_name, school_name, school_id, org_name, domain_name, criteria_name, score,
              has_parent_question, parent_question_text, evidences, remarks, completed_date)
          case "multiselect" =>
            questionsFunction.multiselectQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, roles, program_name, program_id,
              observation_name, observation_id, value, state_name, district_name, block_name, cluster_name, school_name, school_id, org_name, domain_name, criteria_name, score,
              has_parent_question, parent_question_text, evidences, remarks, completed_date)
          case "number" =>
            questionsFunction.numberQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, roles, program_name, program_id,
              observation_name, observation_id, value, state_name, district_name, block_name, cluster_name, school_name, school_id, org_name, domain_name, criteria_name, score,
              has_parent_question, parent_question_text, evidences, remarks, completed_date)
          case "slider" =>
            questionsFunction.sliderQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, roles, program_name, program_id,
              observation_name, observation_id, value, state_name, district_name, block_name, cluster_name, school_name, school_id, org_name, domain_name, criteria_name, score,
              has_parent_question, parent_question_text, evidences, remarks, completed_date)
          case "matrix" =>
            questionsMap.get("value") match {
              case Some(valueList: List[Map[String, Any]]) =>
                valueList.foreach { instance =>
                  instance.foreach { case (_, questionData) =>
                    val matrixQuestionMap = questionData.asInstanceOf[Map[String, Any]]
                    val matrixQuestionId: String = matrixQuestionMap.get("qid") match {
                      case Some(v: String) => v
                      case _ => ""
                    }
                    val matrixPayload = matrixQuestionMap.get("payload").map(_.asInstanceOf[Map[String, Any]])
                    val matrixResponseType = matrixQuestionMap.get("responseType").map(_.toString).getOrElse("")
                    processQuestion(matrixResponseType, matrixQuestionMap, matrixPayload, matrixQuestionId, domain_name, criteria_name, has_parent_question, parent_question_text, evidences, remarks)
                  }
                }
              case _ => println("No matrix data found.")
            }
          case _ => println(s"Unsupported responseType: $responseType")
        }
      }

      answersKey match {
        case answersMap: Map[_, _] =>
          answersMap.foreach { case (_, value) =>
            val questionsMap = value.asInstanceOf[Map[String, Any]]
            println(s"qid: ${questionsMap.get("qid")}")
            val question_id: String = questionsMap.get("qid") match {
              case Some(v: String) => v
              case _ => ""
            }
            val question_criteria_id: String = questionsMap.get("criteriaId") match {
              case Some(v: String) => v
              case _ => ""
            }
            var domain_name: String = ""
            var criteria_name: String = ""

            val evidences = if (questionsMap.isEmpty) {
              println("Debug: questionsMap is empty")
              null
            } else {
              val extractedEvidences = questionsMap.values.collect {
                case map: Map[String, Any] if map.contains("sourcePath") =>
                  map("sourcePath").toString
              }
              if (extractedEvidences.isEmpty) {
                println("Debug: No sourcePath found in questionsMap")
                null
              } else {
                extractedEvidences.mkString(",")
              }
            }

            val remarks = questionsMap.get("remarks") match {
              case Some(r: String) if r.nonEmpty => r
              case _ => null
            }

            val result = for {
              theme <- themes
              criteriaList = theme("criteria").asInstanceOf[List[Map[String, Any]]]
              matchingCriteria <- criteriaList.find(_("criteriaId") == question_criteria_id)
              themeName = theme("name").toString
              criteriaName <- criteria_event.find(_("_id") == question_criteria_id).map(_("name").toString)
            } yield (themeName, criteriaName)

            result.foreach { case (themeName, criteriaName) =>
              domain_name = themeName
              criteria_name = criteriaName
              println(s"Theme Name: $themeName, Criteria Name: $criteriaName")
            }

            val payload = questionsMap.get("payload") match {
              case Some(value: Map[String, Any]) => Some(value)
              case _ => None
            }
            val responseType = questionsMap.get("responseType").map(_.toString).getOrElse("")

            if (responseType == "matrix") {
              val parent_question_text: String = questionsMap.get("question") match {
                case Some(qList: List[_]) =>
                  qList.collect { case q: String if q.nonEmpty => q }.headOption.getOrElse("")
                case Some(q: String) => q
                case _ => ""
              }
              val has_parent_question: Boolean = parent_question_text.nonEmpty

              processQuestion(responseType, questionsMap, payload, question_id, domain_name, criteria_name, has_parent_question, parent_question_text, evidences, remarks)
            } else {
              processQuestion(responseType, questionsMap, payload, question_id, domain_name, criteria_name, false, null, evidences, remarks)
            }
          }
        case _ =>
          logger.error("Unexpected structure for answers field")
      }

      /**
       * Logic to populate kafka messages for creating metabase dashboard
       */
      val obsDashboardData = new java.util.HashMap[String, Any]()
      obsDashboardData.put("chart_type", util.Arrays.asList("domain", "question"))
      obsDashboardData.put("isRubric", event.isRubric.toString)
      obsDashboardData.put("solutionName",event.solutionName)
      obsDashboardData.put("solution_id", event.solutionId)

      pushProjectDashboardEvents(obsDashboardData, context)
    }

    if (status_of_submission != null) {

      val createStatusTable =
        s"""CREATE TABLE IF NOT EXISTS $statusTable (
           |    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
           |    user_id TEXT ,
           |    user_roles TEXT,
           |    solution_id TEXT ,
           |    solution_name TEXT,
           |    submission_id TEXT,
           |    program_name TEXT,
           |    program_id TEXT,
           |    observation_name TEXT,
           |    observation_id TEXT,
           |    state_name TEXT,
           |    district_name TEXT,
           |    block_name TEXT,
           |    cluster_name TEXT,
           |    school_name TEXT,
           |    school_id TEXT,
           |    org_name TEXT,
           |    status_of_submission TEXT,
           |    submitted_at TEXT
           |);""".stripMargin

      checkAndCreateTable(statusTable, createStatusTable)

      val deleteQuery =
        s"""DELETE FROM $statusTable
           |WHERE user_id = ?
           |  AND state_name = ?
           |  AND district_name = ?
           |  AND block_name = ?
           |  AND cluster_name = ?
           |  AND school_name = ?
           |  AND status_of_submission = ?;
           |""".stripMargin

      val deleteParams = Seq(user_id, state_name, district_name, block_name, cluster_name, school_name, status_of_submission)

      postgresUtil.executePreparedUpdate(deleteQuery, deleteParams, statusTable, user_id)

      val insertStatusQuery =
        s"""INSERT INTO $statusTable (
           |    user_id, user_roles, solution_id, solution_name, submission_id, program_name, program_id,
           |    observation_name, observation_id, state_name, district_name, block_name, cluster_name, org_name,
           |    school_name, school_id, status_of_submission, submitted_at
           |) VALUES (
           |        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
           |);
           |""".stripMargin

      val statusParams = Seq(
        user_id, roles, solution_id, solution_name, submission_id, program_name,
        program_id, observation_name, observation_id, state_name, district_name, block_name, cluster_name,
        org_name, school_name, school_id, status_of_submission, completed_date
      )

      postgresUtil.executePreparedUpdate(insertStatusQuery, statusParams, statusTable, solution_id)
    }

    def pushProjectDashboardEvents(dashboardData: util.HashMap[String, Any], context: ProcessFunction[Event, Event]#Context): util.HashMap[String, AnyRef] = {
      val objects = new util.HashMap[String, AnyRef]() {
        put("_id", java.util.UUID.randomUUID().toString)
        put("reportType", "Observation")
        put("publishedAt", DateTimeFormatter
          .ofPattern("yyyy-MM-dd HH:mm:ss")
          .withZone(ZoneId.systemDefault())
          .format(Instant.ofEpochMilli(System.currentTimeMillis())).asInstanceOf[AnyRef])
        put("chart_type", dashboardData.get("chart_type").asInstanceOf[AnyRef])
        put("solution_id", dashboardData.get("solution_id").asInstanceOf[AnyRef])
        put("isRubric", dashboardData.get("isRubric").asInstanceOf[AnyRef])
        put("solutionName", dashboardData.get("solutionName").asInstanceOf[AnyRef])
      }
      val event = ScalaJsonUtil.serialize(objects)
      context.output(config.eventOutputTag, event)
      println(s"----> Pushed new Kafka message to ${config.outputTopic} topic")
      println(objects)
      objects
    }
  }

}