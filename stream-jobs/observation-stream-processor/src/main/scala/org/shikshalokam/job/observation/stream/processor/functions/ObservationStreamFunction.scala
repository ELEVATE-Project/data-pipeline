package org.shikshalokam.job.observation.stream.processor.functions

import org.apache.flink.api.common.typeinfo.TypeInformation
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.functions.ProcessFunction
import org.shikshalokam.job.observation.stream.processor.domain.Event
import org.shikshalokam.job.observation.stream.processor.task.ObservationStreamConfig
import org.shikshalokam.job.util.{PostgresUtil, ScalaJsonUtil}
import org.shikshalokam.job.{BaseProcessFunction, Metrics}
import org.slf4j.LoggerFactory

import java.util
import java.time.{Instant, ZoneId}
import java.time.format.DateTimeFormatter
import scala.collection.immutable._

class ObservationStreamFunction(config: ObservationStreamConfig)(implicit val mapTypeInfo: TypeInformation[Event], @transient var postgresUtil: PostgresUtil = null)
  extends BaseProcessFunction[Event, Event](config) {

  private[this] val logger = LoggerFactory.getLogger(classOf[ObservationStreamFunction])

  override def metricsList(): List[String] = {
    List(config.observationCleanupHit, config.skipCount, config.successCount, config.totalEventsCount)
  }

  override def open(parameters: Configuration): Unit = {
    super.open(parameters)
    val pgHost: String = config.pgHost
    val pgPort: String = config.pgPort
    val pgUsername: String = config.pgUsername
    val pgPassword: String = config.pgPassword
    val pgDataBase: String = config.pgDataBase
    val connectionUrl: String = s"jdbc:postgresql://$pgHost:$pgPort/$pgDataBase"
    postgresUtil = new PostgresUtil(connectionUrl, pgUsername, pgPassword)
  }

  override def close(): Unit = {
    super.close()
  }

  override def processElement(event: Event, context: ProcessFunction[Event, Event]#Context, metrics: Metrics): Unit = {

    println(s"***************** Start of Processing the Observation Event with Id = ${event._id} *****************")

    println("\n==> domain data ")
    println("solutionId = " + event.solutionId)
    println("submissionId = " + event._id)
    println("userId = " + event.createdBy)
    println("submissionNumber = " + event.submissionNumber)
    println("stateName = " + event.stateName)
    println("districtName = " + event.districtName)
    println("blockName = " + event.blockName)
    println("clusterName = " + event.clusterName)
    println("schoolName = " + event.schoolName)
    println("status = " + event.status)
    println("solutionName = " + event.solutionName)

    if (event.status == "completed") {

      /**
       * Creating tables if not exists
       */

      def checkAndCreateTable(tableName: String, createTableQuery: String): Unit = {
        val checkTableExistsQuery =
          s"""SELECT EXISTS (
             |  SELECT FROM information_schema.tables
             |  WHERE table_name = '$tableName'
             |);
             |""".stripMargin

        val tableExists = postgresUtil.executeQuery(checkTableExistsQuery) { resultSet =>
          if (resultSet.next()) resultSet.getBoolean(1) else false
        }

        if (!tableExists) {
          postgresUtil.createTable(createTableQuery, tableName)
        }
      }
      val solution_id = event.solutionId
      val solution_name = event.solutionName
      val domainTable = s""""${solution_id}_domain""""
      val questionTable = s""""${solution_id}_questions""""


      val createDomainsTable =
        s"""CREATE TABLE IF NOT EXISTS $domainTable (
           |    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
           |    solution_id TEXT ,
           |    solution_name TEXT,
           |    submission_id TEXT,
           |    user_id TEXT ,
           |    submission_number INTEGER,
           |    state_name TEXT,
           |    district_name TEXT,
           |    block_name TEXT,
           |    cluster_name TEXT,
           |    school_name TEXT,
           |    record_type TEXT,
           |    domain TEXT,
           |    subdomain TEXT,
           |    criteria TEXT,
           |    record_value TEXT,
           |    max_scores INTEGER,
           |    scores_achived INTEGER
           |);""".stripMargin


      val createQuestionsTable =
        s"""CREATE TABLE IF NOT EXISTS $questionTable (
           |    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
           |    solution_id TEXT ,
           |    solution_name TEXT,
           |    submission_id TEXT,
           |    user_id TEXT ,
           |    state_name TEXT,
           |    district_name TEXT,
           |    block_name TEXT,
           |    cluster_name TEXT,
           |    school_name TEXT,
           |    org_name TEXT,
           |    question_id TEXT,
           |    question_text TEXT,
           |    labels TEXT,
           |    value TEXT,
           |    score INTEGER,
           |    domain_name TEXT,
           |    criteria_name TEXT,
           |    has_parent_question BOOLEAN,
           |    parent_question_text TEXT,
           |    evidence TEXT,
           |    submitted_at TEXT,
           |    remarks TEXT,
           |    question_type TEXT
           |);""".stripMargin

      checkAndCreateTable(domainTable, createDomainsTable)
      checkAndCreateTable(questionTable, createQuestionsTable)

      /**
       * Extracting domain data
       */

      val submission_id = event._id
      val user_id = event.createdBy
      val submission_number = event.submissionNumber
      val state_name = event.stateName
      val district_name = event.districtName
      val block_name = event.blockName
      val cluster_name = event.clusterName
      val school_name = event.schoolName
      val themes = event.themes
      val criteria_event = event.criteria

      val deleteQuery =
        s"""DELETE FROM $domainTable
           |WHERE user_id = ?
           |  AND state_name = ?
           |  AND district_name = ?
           |  AND block_name = ?
           |  AND cluster_name = ?
           |  AND school_name = ?;
           |""".stripMargin

      val deleteParams = Seq(user_id, state_name, district_name, block_name, cluster_name, school_name)

      postgresUtil.executePreparedUpdate(deleteQuery, deleteParams, domainTable, user_id)

      themes.foreach { domain =>
        val domain_name = domain("name")
        val level = domain.getOrElse("pointsBasedLevel", 0)

        val insertDomainQuery =
          s"""INSERT INTO $domainTable (
             |    solution_id, solution_name, submission_id, user_id, submission_number, state_name, district_name,
             |    block_name, cluster_name, school_name, record_type,
             |    domain, subdomain, criteria, record_value, max_scores, scores_achived
             |) VALUES (
             |   ?, ?, ?, ?, ?, ?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
             |);
             |""".stripMargin

        val domainParams = Seq(solution_id, solution_name, submission_id, user_id, submission_number, state_name, district_name,
          block_name, cluster_name, school_name, "domain", domain_name, null, null, level, null, null)

        postgresUtil.executePreparedUpdate(insertDomainQuery, domainParams, domainTable, solution_id)

        val maybeChildren = domain.get("children").map(_.asInstanceOf[List[Map[String, Any]]])
        val maybeCriteria = domain.get("criteria").map(_.asInstanceOf[List[Map[String, Any]]])

        maybeChildren match {
          case Some(subdomains) =>
            subdomains.foreach { subdomain =>
              val maybeSubCriteria = subdomain.get("criteria").map(_.asInstanceOf[List[Map[String, Any]]])
              maybeSubCriteria.foreach { criteriaList =>
                criteriaList.foreach { criteria =>
                  val criteriaId = criteria("criteriaId")

                  criteria_event.find(_("_id") == criteriaId).foreach { crit =>
                  }
                }
              }
            }

          case None =>
            maybeCriteria.foreach { criteriaList =>
              criteriaList.foreach { criteria =>
                val criteriaId = criteria("criteriaId")
                println(s"criteria_id: $criteriaId")

                criteria_event.find(c => c("_id") == criteriaId).foreach { crit =>
                  val criteria_name = crit("name")
                  val criteria_score = crit("score")
                  val insertCriteriaQuery =
                    s"""INSERT INTO $domainTable (
                       |    solution_id, solution_name, submission_id, user_id, submission_number, state_name, district_name,
                       |    block_name, cluster_name, school_name, record_type,
                       |    domain, subdomain, criteria, record_value, max_scores, scores_achived
                       |) VALUES (
                       |        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                       |);
                       |""".stripMargin
                  val  criteriaParams = Seq(solution_id, solution_name, submission_id, user_id, submission_number, state_name, district_name,
                    block_name, cluster_name, school_name, "criteria", domain_name, null, criteria_name, criteria_score, null, null)

                  postgresUtil.executePreparedUpdate(insertCriteriaQuery, criteriaParams, domainTable, solution_id)
                }
              }
            }
        }
      }
      /**
       * Extracting school_level score data
       */
      val max_score = event.pointsBasedMaxScore
      val score_achived = event.pointsBasedScoreAchieved

      val insertSchoolLevelScoreQuery =
        s"""INSERT INTO $domainTable (
           |    solution_id, solution_name, submission_id, user_id, submission_number, state_name, district_name,
           |    block_name, cluster_name, school_name, record_type,
           |    domain, subdomain, criteria, record_value, max_scores, scores_achived
           |) VALUES (
           |         ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
           |);
           |""".stripMargin

      val schoolLevelScoreParams = Seq(solution_id, solution_name, submission_id, user_id, submission_number, state_name, district_name,
        block_name, cluster_name, school_name, "score", null, null, null, null, max_score, score_achived)

      postgresUtil.executePreparedUpdate(insertSchoolLevelScoreQuery, schoolLevelScoreParams, domainTable, solution_id)

      /**
       * Extracting question data
       */

      val deleteQuestionQuery =
        s"""DELETE FROM $questionTable
           |WHERE user_id = ?
           |  AND state_name = ?
           |  AND district_name = ?
           |  AND block_name = ?
           |  AND cluster_name = ?
           |  AND school_name = ?;
           |""".stripMargin

      val deleteQuestionParams = Seq(user_id, state_name, district_name, block_name, cluster_name, school_name)

      postgresUtil.executePreparedUpdate(deleteQuestionQuery, deleteQuestionParams, questionTable, user_id)

      val questionsFunction = new ObservationQuestionFunction(postgresUtil, config, questionTable)
      val answersKey = event.answers

      def processQuestion(responseType: String, questionsMap: Map[String, Any], payload: Option[Map[String, Any]], question_id: String, domain_name: String, criteria_name: String, has_parent_question: Boolean, parent_question_text: String): Unit = {
        val value: String = questionsMap.get("value") match {
          case Some(v: String) => v
          case Some(v: Int) => v.toString
          case _ => ""
        }
        val score: Integer = questionsMap.get("scoreAchieved") match {
          case Some(v: Integer) => v
          case _ => 0
        }

        responseType match {
          case "text" =>
            questionsFunction.textQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, submission_number, value, state_name,
              district_name, block_name, cluster_name, school_name, domain_name, criteria_name,  has_parent_question, parent_question_text)
          case "radio" =>
            questionsFunction.radioQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, submission_number, value, state_name,
              district_name, block_name, cluster_name, school_name, domain_name, criteria_name, score, has_parent_question, parent_question_text)
          case "date" =>
            questionsFunction.dateQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, submission_number, value, state_name,
              district_name, block_name, cluster_name, school_name, domain_name, criteria_name, score, has_parent_question, parent_question_text)
          case "multiselect" =>
            questionsFunction.multiselectQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, submission_number, value, state_name,
              district_name, block_name, cluster_name, school_name, domain_name, criteria_name, has_parent_question, parent_question_text)
          case "number" =>
            questionsFunction.numberQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, submission_number, value, state_name,
              district_name, block_name, cluster_name, school_name, domain_name, criteria_name, has_parent_question, parent_question_text)
          case "slider" =>
            questionsFunction.sliderQuestionType(payload, question_id, solution_id, solution_name, submission_id, user_id, submission_number, value, state_name,
              district_name, block_name, cluster_name, school_name, domain_name, criteria_name, has_parent_question, parent_question_text)
          case "matrix" =>
            questionsMap.get("value") match {
              case Some(valueList: List[Map[String, Any]]) =>
                valueList.foreach { instance =>
                  instance.foreach { case (_, questionData) =>
                    val matrixQuestionMap = questionData.asInstanceOf[Map[String, Any]]
                    val matrixQuestionId: String = matrixQuestionMap.get("qid") match {
                      case Some(v: String) => v
                      case _ => ""
                    }
                    val matrixPayload = matrixQuestionMap.get("payload").map(_.asInstanceOf[Map[String, Any]])
                    val matrixResponseType = matrixQuestionMap.get("responseType").map(_.toString).getOrElse("")
                    processQuestion(matrixResponseType, matrixQuestionMap, matrixPayload, matrixQuestionId, domain_name, criteria_name, has_parent_question, parent_question_text)
                  }
                }
              case _ => println("No matrix data found.")
            }
          case _ => println(s"Unsupported responseType: $responseType")
        }
      }

      answersKey match {
        case answersMap: Map[_, _] =>
          answersMap.foreach { case (_, value) =>
            val questionsMap = value.asInstanceOf[Map[String, Any]]
            println(s"qid: ${questionsMap.get("qid")}")
            val question_id: String = questionsMap.get("qid") match {
              case Some(v: String) => v
              case _ => ""
            }
            val question_criteria_id: String = questionsMap.get("criteriaId") match {
              case Some(v: String) => v
              case _ => ""
            }
            var domain_name: String = ""
            var criteria_name: String = ""
            // Find the theme name and criteria name
            val result = for {
              theme <- themes
              criteriaList = theme("criteria").asInstanceOf[List[Map[String, Any]]]
              matchingCriteria <- criteriaList.find(_("criteriaId") == question_criteria_id)
              themeName = theme("name").toString
              criteriaName <- criteria_event.find(_("_id") == question_criteria_id).map(_("name").toString)
            } yield (themeName, criteriaName)

            result.foreach { case (themeName, criteriaName) =>
              domain_name = themeName
              criteria_name = criteriaName
              println(s"Theme Name: $themeName, Criteria Name: $criteriaName")
            }

            val payload = questionsMap.get("payload") match {
              case Some(value: Map[String, Any]) => Some(value)
              case _ => None
            }
            val responseType = questionsMap.get("responseType").map(_.toString).getOrElse("")

            if (responseType == "matrix") {
              val parent_question_text: String = questionsMap.get("question") match {
                case Some(qList: List[_]) =>
                  qList.collect { case q: String if q.nonEmpty => q }.headOption.getOrElse("")
                case Some(q: String) => q
                case _ => ""
              }
              val has_parent_question: Boolean = parent_question_text.nonEmpty

              processQuestion(responseType, questionsMap, payload, question_id, domain_name, criteria_name, has_parent_question, parent_question_text)
            } else {
              processQuestion(responseType, questionsMap, payload, question_id, domain_name, criteria_name, false, null)
            }
          }
        case _ =>
          logger.error("Unexpected structure for answers field")
      }

      /**
       * Logic to populate kafka messages for creating metabase dashboard
       */
      val obsDashboardData = new java.util.HashMap[String, Any]()
      obsDashboardData.put("chart_type", util.Arrays.asList("domain", "question"))
      obsDashboardData.put("isRubric", event.isRubric.toString)
      obsDashboardData.put("solutionName",event.solutionName)
      obsDashboardData.put("solution_id", event.solutionId)

      pushProjectDashboardEvents(obsDashboardData, context)
    }


    def pushProjectDashboardEvents(dashboardData: util.HashMap[String, Any], context: ProcessFunction[Event, Event]#Context): util.HashMap[String, AnyRef] = {
      val objects = new util.HashMap[String, AnyRef]() {
        put("_id", java.util.UUID.randomUUID().toString)
        put("reportType", "Observation")
        put("publishedAt", DateTimeFormatter
          .ofPattern("yyyy-MM-dd HH:mm:ss")
          .withZone(ZoneId.systemDefault())
          .format(Instant.ofEpochMilli(System.currentTimeMillis())).asInstanceOf[AnyRef])
        put("chart_type", dashboardData.get("chart_type").asInstanceOf[AnyRef])
        put("solution_id", dashboardData.get("solution_id").asInstanceOf[AnyRef])
        put("isRubric", dashboardData.get("isRubric").asInstanceOf[AnyRef])
        put("solutionName", dashboardData.get("solutionName").asInstanceOf[AnyRef])
      }
      val event = ScalaJsonUtil.serialize(objects)
      context.output(config.eventOutputTag, event)
      println(s"----> Pushed new Kafka message to ${config.outputTopic} topic")
      println(objects)
      objects
    }
  }

}