package org.shikshalokam.job.survey.stream.processor.functions

import org.apache.flink.api.common.typeinfo.TypeInformation
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.functions.ProcessFunction
import org.shikshalokam.job.survey.stream.processor.domain.Event
import org.shikshalokam.job.survey.stream.processor.task.SurveyStreamConfig
import org.shikshalokam.job.util.{PostgresUtil, ScalaJsonUtil}
import org.shikshalokam.job.{BaseProcessFunction, Metrics}
import org.slf4j.LoggerFactory

import java.util
import java.time.{Instant, ZoneId}
import java.time.format.DateTimeFormatter
import scala.collection.immutable._

class SurveyStreamFunction(config: SurveyStreamConfig)(implicit val mapTypeInfo: TypeInformation[Event], @transient var postgresUtil: PostgresUtil = null)
  extends BaseProcessFunction[Event, Event](config) {

  private[this] val logger = LoggerFactory.getLogger(classOf[SurveyStreamFunction])

  override def metricsList(): List[String] = {
    List(config.surveysCleanupHit, config.skipCount, config.successCount, config.totalEventsCount)
  }

  override def open(parameters: Configuration): Unit = {
    super.open(parameters)
    val pgHost: String = config.pgHost
    val pgPort: String = config.pgPort
    val pgUsername: String = config.pgUsername
    val pgPassword: String = config.pgPassword
    val pgDataBase: String = config.pgDataBase
    val connectionUrl: String = s"jdbc:postgresql://$pgHost:$pgPort/$pgDataBase"
    postgresUtil = new PostgresUtil(connectionUrl, pgUsername, pgPassword)
  }

  override def close(): Unit = {
    super.close()
  }

  override def processElement(event: Event, context: ProcessFunction[Event, Event]#Context, metrics: Metrics): Unit = {
    println(s"***************** Start of Processing the Survey Event with Id = ${event._id} *****************")
    val (roleIds, roles) = extractUserRolesData(event.userRoles)

    println("\n==> Solutions Data ")
    println("solutionId = " + event.solutionId)
    println("solutionExternalId = " + event.solutionExternalId)
    println("solutionName = " + event.solutionName)
    println("solutionDescription = " + event.solutionDescription)
    println("programId = " + event.programId)
    println("programExternalId = " + event.programExternalId)
    println("programName = " + event.programName)
    println("programDescription = " + event.programDescription)

    //      println("\n==> Survey Data ")
    //      println("userId = " + event.createdBy)
    //      println("organisationId = " + event.organisationId)
    //      println("organisationName = " + event.organisationName)
    //      println("organisationCode = " + event.organisationCode)
    //      println("userRoleIds = " + roleIds)
    //      println("userRoles = " + roles)
    //      println("stateId = " + event.stateId)
    //      println("stateName = " + event.stateName)
    //      println("districtId = " + event.districtId)
    //      println("districtName = " + event.districtName)
    //      println("blockId = " + event.blockId)
    //      println("blockName = " + event.blockName)
    //      println("clusterId = " + event.clusterId)
    //      println("clusterName = " + event.clusterName)
    //      println("schoolId = " + event.schoolId)
    //      println("schoolName = " + event.schoolName)

    val surveyQuestionTable = event.solutionId
    val createSurveyQuestionsTableQuery =
      s"""CREATE TABLE IF NOT EXISTS "$surveyQuestionTable" (
         |    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
         |    solution_id TEXT ,
         |    solution_name TEXT,
         |    user_id TEXT ,
         |    state_name TEXT,
         |    district_name TEXT,
         |    block_name TEXT,
         |    cluster_name TEXT,
         |    school_name TEXT,
         |    question_id TEXT,
         |    question_text TEXT,
         |    labels TEXT,
         |    value TEXT,
         |    has_parent_question BOOLEAN,
         |    parent_question_text TEXT,
         |    evidence TEXT,
         |    question_type TEXT
         |);""".stripMargin


    //TODO: enable this after confirmation
    if (event.status == "completed") {
      postgresUtil.createTable(config.createSolutionsTable, config.solutions)
      postgresUtil.createTable(config.createDashboardMetadataTable, config.dashboard_metadata)
      postgresUtil.checkAndCreateTable(surveyQuestionTable, createSurveyQuestionsTableQuery)

      /**
       * Extracting Solutions data
       */
      val solutionId = event.solutionId
      val solutionExternalId = event.solutionExternalId
      val solutionName = event.solutionName
      val solutionDescription = event.solutionDescription
      val programId = event.programId
      val programName = event.programName
      val programExternalId = event.programExternalId
      val programDescription = event.programDescription
      val privateProgram = null
      val projectCategories = null
      val projectDuration = null

      val upsertSolutionQuery =
        s"""INSERT INTO ${config.solutions} (solution_id, external_id, name, description, duration, categories, program_id, program_name, program_external_id, program_description, private_program)
           |VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
           |ON CONFLICT (solution_id) DO UPDATE SET
           |    external_id = ?,
           |    name = ?,
           |    description = ?,
           |    duration = ?,
           |    categories = ?,
           |    program_id = ?,
           |    program_name = ?,
           |    program_external_id = ?,
           |    program_description = ?,
           |    private_program = ?;
           |""".stripMargin

      val solutionParams = Seq(
        // Insert parameters
        solutionId, solutionExternalId, solutionName, solutionDescription, projectDuration, projectCategories, programId, programName, programExternalId, programDescription, privateProgram,

        // Update parameters (matching columns in the ON CONFLICT clause)
        solutionExternalId, solutionName, solutionDescription, projectDuration, projectCategories, programId, programName, programExternalId, programDescription, privateProgram
      )

      postgresUtil.executePreparedUpdate(upsertSolutionQuery, solutionParams, config.solutions, solutionId)

      /**
       * Extracting Survey Data
       * TODO: add the implementation logic
       */
      //        println("\n==> Survey Question Data ")
      //        println("solutionId = " + event.solutionId)
      //        println("solutionName = " + event.solutionName)
      //        println("userId = " + event.createdBy)
      //        println("stateName = " + event.stateName)
      //        println("districtName = " + event.districtName)
      //        println("blockName = " + event.blockName)
      //        println("clusterName = " + event.clusterName)
      //        println("schoolName = " + event.schoolName)
      //        println("question_id = " + event.schoolName)
      //        println("question_text = " + event.schoolName)
      //        println("labels = " + event.schoolName)
      //        println("value = " + event.schoolName)
      //        println("has_parent_question = " + event.schoolName)
      //        println("parent_question_text = " + event.schoolName)
      //        println("evidence = " + event.schoolName)
      //        println("submitted_at = " + event.schoolName)
      //        println("remarks = " + event.schoolName)
      //        println("question_type = " + event.schoolName)

      /**
       * Extracting Survey Questions Data
       */
      val solution_id = event._id
      val solution_name = event.solutionName
      val user_id = event.createdBy
      val state_name = event.stateName
      val district_name = event.districtName
      val block_name = event.blockName
      val cluster_name = event.clusterName
      val school_name = event.schoolName
      val answersKey = event.answers

      val deleteQuestionQuery =
        s"""DELETE FROM "$surveyQuestionTable"
           |WHERE user_id = ?
           |  AND state_name = ?
           |  AND district_name = ?
           |  AND block_name = ?
           |  AND cluster_name = ?
           |  AND school_name = ?;
           |""".stripMargin
      val deleteQuestionParams = Seq(user_id, state_name, district_name, block_name, cluster_name, school_name)
      postgresUtil.executePreparedUpdate(deleteQuestionQuery, deleteQuestionParams, surveyQuestionTable, user_id)

      answersKey match {
        case answersMap: Map[_, _] =>
          answersMap.foreach { case (_, value) =>
            val questionsMap = value.asInstanceOf[Map[String, Any]]
            val question_id: String = questionsMap.get("qid").collect { case v: String => v }.getOrElse("")
            val payloadOpt: Option[Map[String, Any]] = questionsMap.get("payload").collect { case m: Map[String@unchecked, Any@unchecked] => m }
            val responseType = questionsMap.get("responseType").map(_.toString).getOrElse("")

            if (payloadOpt.isDefined) {
              if (responseType == "matrix") {
                val parent_question_text: String = questionsMap.get("payload") match {
                  case Some(payloadMap: Map[_, _]) =>
                    payloadMap.asInstanceOf[Map[String, Any]].get("question") match {
                      case Some(qList: List[_]) =>
                        qList.collect { case q: String if q.nonEmpty => q }.headOption.getOrElse("")
                      case Some(q: String) => q
                      case _ => ""
                    }
                  case _ => ""
                }
                val has_parent_question: Boolean = parent_question_text.nonEmpty

                processQuestion(responseType, questionsMap, payloadOpt, question_id, has_parent_question, parent_question_text)
              } else {
                processQuestion(responseType, questionsMap, payloadOpt, question_id, has_parent_question = false, parent_question_text = null)
              }
            } else {
              println(s"Skipping question_id=$question_id as payload is missing.")
            }
          }

        case _ =>
          logger.error("Unexpected structure for answers field")
      }


      def processQuestion(responseType: String, questionsMap: Map[String, Any], payload: Option[Map[String, Any]], question_id: String, has_parent_question: Boolean, parent_question_text: String): Unit = {
        val value: String = questionsMap.get("value") match {
          case Some(v: String) => v
          case Some(v: Int) => v.toString
          case _ => ""
        }
        val score: Integer = questionsMap.get("scoreAchieved") match {
          case Some(v: Integer) => v
          case _ => 0
        }

        responseType match {
          case "text" =>
            textQuestionType(payload, question_id, solution_id, solution_name, user_id, value, state_name,
              district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text)
          case "radio" =>
            radioQuestionType(payload, question_id, solution_id, solution_name, user_id, value, state_name,
              district_name, block_name, cluster_name, school_name, score, has_parent_question, parent_question_text)
          case "date" =>
            dateQuestionType(payload, question_id, solution_id, solution_name, user_id, value, state_name,
              district_name, block_name, cluster_name, school_name, score, has_parent_question, parent_question_text)
          case "multiselect" =>
            multiselectQuestionType(payload, question_id, solution_id, solution_name, user_id, value, state_name,
              district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text)
          case "number" =>
            numberQuestionType(payload, question_id, solution_id, solution_name, user_id, value, state_name,
              district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text)
          case "slider" =>
            sliderQuestionType(payload, question_id, solution_id, solution_name, user_id, value, state_name,
              district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text)
          case "matrix" =>
            questionsMap.get("value") match {
              case Some(valueList: List[Map[String, Any]]) =>
                valueList.foreach { instance =>
                  instance.foreach { case (_, questionData) =>
                    val matrixQuestionMap = questionData.asInstanceOf[Map[String, Any]]
                    val matrixQuestionId: String = matrixQuestionMap.get("qid") match {
                      case Some(v: String) => v
                      case _ => ""
                    }
                    val matrixPayload = matrixQuestionMap.get("payload").map(_.asInstanceOf[Map[String, Any]])
                    val matrixResponseType = matrixQuestionMap.get("responseType").map(_.toString).getOrElse("")
                    processQuestion(matrixResponseType, matrixQuestionMap, matrixPayload, matrixQuestionId, has_parent_question, parent_question_text)
                  }
                }
              case _ => println("No matrix data found.")
            }
          case _ => println(s"Unsupported responseType: $responseType")
        }
      }

    }

    def extractField(payload: Option[Map[String, Any]], key: String): String = {
      payload.flatMap(_.get(key)) match {
        case Some(qList: List[_]) =>
          qList.collect { case q if q != null => q.toString }.headOption.getOrElse("")
        case _ => ""
      }
    }

    def insertQuestion(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                       user_id: String, value: String, state_name: String, district_name: String,
                       block_name: String, cluster_name: String, school_name: String, has_parent_question: Boolean,
                       parent_question_text: String, question_type: String): Unit = {

      if (!payload.exists(_.contains("labels"))) {
        println(s"Skipping question $question_id as 'labels' key is missing.")
        return
      }

      val question = extractField(payload, "question")
      val labels = extractField(payload, "labels")

      val insertQuestionQuery =
        s"""INSERT INTO "$surveyQuestionTable" (
           |    solution_id, solution_name, user_id, state_name, district_name, block_name, cluster_name, school_name,
           |    question_id, question_text, labels, value, has_parent_question, parent_question_text, evidence, question_type
           |) VALUES (
           |   ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
           |);
           |""".stripMargin


      val questionParam = Seq(
        solution_id, solution_name, user_id, state_name, district_name, block_name, cluster_name, school_name,
        question_id, question, labels, value, has_parent_question, parent_question_text, null, question_type
      )
      postgresUtil.executePreparedUpdate(insertQuestionQuery, questionParam, surveyQuestionTable, solution_id)
    }

    def textQuestionType(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                         user_id: String, value: String, state_name: String, district_name: String,
                         block_name: String, cluster_name: String, school_name: String, has_parent_question: Boolean,
                         parent_question_text: String): Unit = {
      insertQuestion(payload, question_id, solution_id, solution_name, user_id, value, state_name, district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text, "text")
    }

    def radioQuestionType(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                          user_id: String, value: String, state_name: String, district_name: String,
                          block_name: String, cluster_name: String, school_name: String, score: Integer, has_parent_question: Boolean,
                          parent_question_text: String): Unit = {
      insertQuestion(payload, question_id, solution_id, solution_name, user_id, value, state_name, district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text, "radio")
    }

    def dateQuestionType(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                         user_id: String, value: String, state_name: String, district_name: String,
                         block_name: String, cluster_name: String, school_name: String, score: Integer, has_parent_question: Boolean,
                         parent_question_text: String): Unit = {
      insertQuestion(payload, question_id, solution_id, solution_name, user_id, value, state_name, district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text, "date")
    }

    def multiselectQuestionType(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                                user_id: String, value: String, state_name: String, district_name: String,
                                block_name: String, cluster_name: String, school_name: String, has_parent_question: Boolean,
                                parent_question_text: String): Unit = {
      insertQuestion(payload, question_id, solution_id, solution_name, user_id, value, state_name, district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text, "multiselect")
    }

    def numberQuestionType(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                           user_id: String, value: String, state_name: String, district_name: String,
                           block_name: String, cluster_name: String, school_name: String, has_parent_question: Boolean,
                           parent_question_text: String): Unit = {
      insertQuestion(payload, question_id, solution_id, solution_name, user_id, value, state_name, district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text, "number")
    }

    def sliderQuestionType(payload: Option[Map[String, Any]], question_id: String, solution_id: String, solution_name: String,
                           user_id: String, value: String, state_name: String, district_name: String,
                           block_name: String, cluster_name: String, school_name: String, has_parent_question: Boolean,
                           parent_question_text: String): Unit = {
      insertQuestion(payload, question_id, solution_id, solution_name, user_id, value, state_name, district_name, block_name, cluster_name, school_name, has_parent_question, parent_question_text, "slider")
    }


    /**
     * Logic to populate kafka messages for creating metabase dashboard
     */
    val dashboardData = new java.util.HashMap[String, String]()
    val dashboardConfig = Seq(
      ("admin", "1", "admin"),
      ("program", event.programId, "targetedProgram"),
      ("solution", event.solutionId, "targetedSolution")
    )

    dashboardConfig
      .filter { case (key, _, _) => config.reportsEnabled.contains(key) }
      .foreach { case (key, value, target) =>
        checkAndInsert(key, value, dashboardData, target)
      }

    if (!dashboardData.isEmpty) {
      pushSurveyDashboardEvents(dashboardData, context)
    }

  }

  def extractUserRolesData(roles: List[Map[String, Any]]): (String, String) = {
    if (roles == null || roles.isEmpty) {
      ("", "")
    } else {
      val roleId = roles.map { role => role.get("id").map(_.toString).getOrElse("") }
      val roleName = roles.map { role => role.get("title").map(_.toString).getOrElse("") }
      (roleId.mkString(", "), roleName.mkString(", "))
    }
  }

  def checkAndInsert(entityType: String, targetedId: String, dashboardData: java.util.HashMap[String, String], dashboardKey: String): Unit = {
    val query = s"SELECT EXISTS (SELECT 1 FROM ${config.dashboard_metadata} WHERE entity_id = '$targetedId') AS is_${entityType}_present"
    val result = postgresUtil.fetchData(query)

    result.foreach { row =>
      row.get(s"is_${entityType}_present") match {
        case Some(isPresent: Boolean) if isPresent =>
          println(s"$entityType details already exist.")
        case _ =>
          if (entityType == "admin") {
            val insertQuery = s"INSERT INTO ${config.dashboard_metadata} (entity_type, entity_name, entity_id) VALUES ('$entityType', 'Admin', '$targetedId')"
            val affectedRows = postgresUtil.insertData(insertQuery)
            println(s"Inserted Admin details. Affected rows: $affectedRows")
            dashboardData.put(dashboardKey, "1")
          } else {
            val getEntityNameQuery =
              s"""
                 |SELECT DISTINCT ${
                if (entityType == "solution") "name"
                else s"${entityType}_name"
              } AS ${entityType}_name
                 |FROM ${
                entityType match {
                  case "program" => config.solutions
                  case "solution" => config.solutions
                }
              }
                 |WHERE ${entityType}_id = '$targetedId'
               """.stripMargin.replaceAll("\n", " ")
            val result = postgresUtil.fetchData(getEntityNameQuery)
            result.foreach { id =>
              val entityName = id.get(s"${entityType}_name").map(_.toString).getOrElse("")
              val upsertMetaDataQuery =
                s"""INSERT INTO ${config.dashboard_metadata} (
                   |    entity_type, entity_name, entity_id
                   |) VALUES (
                   |    ?, ?, ?
                   |) ON CONFLICT (entity_id) DO UPDATE SET
                   |    entity_type = ?, entity_name = ?;
                   |""".stripMargin

              val dashboardParams = Seq(
                entityType, entityName, targetedId, // Insert parameters
                entityType, entityName // Update parameters (matching columns in the ON CONFLICT clause)
              )
              postgresUtil.executePreparedUpdate(upsertMetaDataQuery, dashboardParams, config.dashboard_metadata, targetedId)
              println(s"Inserted [$entityName : $targetedId] details.")
              dashboardData.put(dashboardKey, targetedId)
            }
          }
      }
    }
  }

  def pushSurveyDashboardEvents(dashboardData: util.HashMap[String, String], context: ProcessFunction[Event, Event]#Context): util.HashMap[String, AnyRef] = {
    val objects = new util.HashMap[String, AnyRef]() {
      put("_id", java.util.UUID.randomUUID().toString)
      put("reportType", "Survey")
      put("publishedAt", DateTimeFormatter
        .ofPattern("yyyy-MM-dd HH:mm:ss")
        .withZone(ZoneId.systemDefault())
        .format(Instant.ofEpochMilli(System.currentTimeMillis())).asInstanceOf[AnyRef])
      put("dashboardData", dashboardData)
    }
    val event = ScalaJsonUtil.serialize(objects)
    context.output(config.eventOutputTag, event)
    println(s"----> Pushed new Kafka message to ${config.outputTopic} topic")
    println(objects)
    objects
  }

}